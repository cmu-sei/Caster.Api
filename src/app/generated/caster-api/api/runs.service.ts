/**
 * Crucible
 * Copyright 2020 Carnegie Mellon University.
 * NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
 * Released under a MIT (SEI)-style license, please see license.txt or contact permission@sei.cmu.edu for full terms.
 * [DISTRIBUTION STATEMENT A] This material has been approved for public release and unlimited distribution.  Please see Copyright notice for non-US Government use and distribution.
 * Carnegie Mellon(R) and CERT(R) are registered in the U.S. Patent and Trademark Office by Carnegie Mellon University.
 * DM20-0181
 */

/**
 * Caster API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { CreateRunCommand } from '../model/createRunCommand';
import { ProblemDetails } from '../model/problemDetails';
import { Run } from '../model/run';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class RunsService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    /**
     * Create a new Run
     * @param CreateRunCommand The Create command
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createRun(CreateRunCommand?: CreateRunCommand, observe?: 'body', reportProgress?: boolean): Observable<Run>;
    public createRun(CreateRunCommand?: CreateRunCommand, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Run>>;
    public createRun(CreateRunCommand?: CreateRunCommand, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Run>>;
    public createRun(CreateRunCommand?: CreateRunCommand, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Run>(`${this.configuration.basePath}/api/runs`,
            CreateRunCommand,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a Run by Id
     * @param id The Id of the Run to retrieve
     * @param IncludePlan Whether to include the Plan resource with the Run
     * @param IncludeApply Whether  to include the Apply resource with the Run
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRun(id: string, IncludePlan?: boolean, IncludeApply?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Run>;
    public getRun(id: string, IncludePlan?: boolean, IncludeApply?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Run>>;
    public getRun(id: string, IncludePlan?: boolean, IncludeApply?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Run>>;
    public getRun(id: string, IncludePlan?: boolean, IncludeApply?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRun.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (IncludePlan !== undefined && IncludePlan !== null) {
            queryParameters = queryParameters.set('IncludePlan', <any>IncludePlan);
        }
        if (IncludeApply !== undefined && IncludeApply !== null) {
            queryParameters = queryParameters.set('IncludeApply', <any>IncludeApply);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Run>(`${this.configuration.basePath}/api/runs/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all Runs
     * @param ActiveOnly If true, only return Active Runs.
     * @param Limit Limit the number of results returned to this amount if present
     * @param IncludePlan Whether to include the Plan resource with the Run
     * @param IncludeApply Whether  to include the Apply resource with the Run
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRuns(ActiveOnly?: boolean, Limit?: number, IncludePlan?: boolean, IncludeApply?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Run>>;
    public getRuns(ActiveOnly?: boolean, Limit?: number, IncludePlan?: boolean, IncludeApply?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Run>>>;
    public getRuns(ActiveOnly?: boolean, Limit?: number, IncludePlan?: boolean, IncludeApply?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Run>>>;
    public getRuns(ActiveOnly?: boolean, Limit?: number, IncludePlan?: boolean, IncludeApply?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (ActiveOnly !== undefined && ActiveOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>ActiveOnly);
        }
        if (Limit !== undefined && Limit !== null) {
            queryParameters = queryParameters.set('Limit', <any>Limit);
        }
        if (IncludePlan !== undefined && IncludePlan !== null) {
            queryParameters = queryParameters.set('IncludePlan', <any>IncludePlan);
        }
        if (IncludeApply !== undefined && IncludeApply !== null) {
            queryParameters = queryParameters.set('IncludeApply', <any>IncludeApply);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Run>>(`${this.configuration.basePath}/api/runs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of Runs for a specified Workspace
     * @param workspaceId The Id of a Workspace
     * @param Limit Limit the number of results returned to this amount if present
     * @param IncludePlan Whether to include the Plan resource with the Run
     * @param IncludeApply Whether  to include the Apply resource with the Run
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRunsByWorkspaceId(workspaceId: string, Limit?: number, IncludePlan?: boolean, IncludeApply?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Run>>;
    public getRunsByWorkspaceId(workspaceId: string, Limit?: number, IncludePlan?: boolean, IncludeApply?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Run>>>;
    public getRunsByWorkspaceId(workspaceId: string, Limit?: number, IncludePlan?: boolean, IncludeApply?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Run>>>;
    public getRunsByWorkspaceId(workspaceId: string, Limit?: number, IncludePlan?: boolean, IncludeApply?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (workspaceId === null || workspaceId === undefined) {
            throw new Error('Required parameter workspaceId was null or undefined when calling getRunsByWorkspaceId.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (Limit !== undefined && Limit !== null) {
            queryParameters = queryParameters.set('Limit', <any>Limit);
        }
        if (IncludePlan !== undefined && IncludePlan !== null) {
            queryParameters = queryParameters.set('IncludePlan', <any>IncludePlan);
        }
        if (IncludeApply !== undefined && IncludeApply !== null) {
            queryParameters = queryParameters.set('IncludeApply', <any>IncludeApply);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Run>>(`${this.configuration.basePath}/api/workspaces/${encodeURIComponent(String(workspaceId))}/runs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reject a Run, preventing it from being Applied
     * @param id The Id of the Run to reject
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rejectRun(id: string, observe?: 'body', reportProgress?: boolean): Observable<Run>;
    public rejectRun(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Run>>;
    public rejectRun(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Run>>;
    public rejectRun(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling rejectRun.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.post<Run>(`${this.configuration.basePath}/api/runs/${encodeURIComponent(String(id))}/actions/reject`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retries saving the state for the specified Run.
     * @param runId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public saveState(runId: string, observe?: 'body', reportProgress?: boolean): Observable<Run>;
    public saveState(runId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Run>>;
    public saveState(runId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Run>>;
    public saveState(runId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (runId === null || runId === undefined) {
            throw new Error('Required parameter runId was null or undefined when calling saveState.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.post<Run>(`${this.configuration.basePath}/api/runs/${encodeURIComponent(String(runId))}/actions/save-state`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
