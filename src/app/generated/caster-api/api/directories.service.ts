/**
 * Crucible
 * Copyright 2020 Carnegie Mellon University.
 * NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
 * Released under a MIT (SEI)-style license, please see license.txt or contact permission@sei.cmu.edu for full terms.
 * [DISTRIBUTION STATEMENT A] This material has been approved for public release and unlimited distribution.  Please see Copyright notice for non-US Government use and distribution.
 * Carnegie Mellon(R) and CERT(R) are registered in the U.S. Patent and Trademark Office by Carnegie Mellon University.
 * DM20-0181
 */

/**
 * Caster API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { ArchiveType } from '../model/archiveType';
import { CreateDirectoryCommand } from '../model/createDirectoryCommand';
import { Directory } from '../model/directory';
import { EditDirectoryCommand } from '../model/editDirectoryCommand';
import { ImportDirectoryResult } from '../model/importDirectoryResult';
import { PartialEditDirectoryCommand } from '../model/partialEditDirectoryCommand';
import { ProblemDetails } from '../model/problemDetails';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class DirectoriesService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Create a new directory.
     * @param CreateDirectoryCommand 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDirectory(CreateDirectoryCommand?: CreateDirectoryCommand, observe?: 'body', reportProgress?: boolean): Observable<Directory>;
    public createDirectory(CreateDirectoryCommand?: CreateDirectoryCommand, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Directory>>;
    public createDirectory(CreateDirectoryCommand?: CreateDirectoryCommand, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Directory>>;
    public createDirectory(CreateDirectoryCommand?: CreateDirectoryCommand, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Directory>(`${this.configuration.basePath}/api/directories`,
            CreateDirectoryCommand,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a directory.
     * @param id ID of a directory.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteDirectory(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteDirectory(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteDirectory(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteDirectory(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteDirectory.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<any>(`${this.configuration.basePath}/api/directories/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a directory.
     * @param id ID of a directory.
     * @param EditDirectoryCommand 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editDirectory(id: string, EditDirectoryCommand?: EditDirectoryCommand, observe?: 'body', reportProgress?: boolean): Observable<Directory>;
    public editDirectory(id: string, EditDirectoryCommand?: EditDirectoryCommand, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Directory>>;
    public editDirectory(id: string, EditDirectoryCommand?: EditDirectoryCommand, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Directory>>;
    public editDirectory(id: string, EditDirectoryCommand?: EditDirectoryCommand, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling editDirectory.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Directory>(`${this.configuration.basePath}/api/directories/${encodeURIComponent(String(id))}`,
            EditDirectoryCommand,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Export a directory.
     * @param id ID of a directory.
     * @param ArchiveType 
     * @param IncludeIds If true, Directory Ids will be appended to their names to be optionally preserved on Import
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public exportDirectory(id: string, ArchiveType?: ArchiveType, IncludeIds?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public exportDirectory(id: string, ArchiveType?: ArchiveType, IncludeIds?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public exportDirectory(id: string, ArchiveType?: ArchiveType, IncludeIds?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public exportDirectory(id: string, ArchiveType?: ArchiveType, IncludeIds?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling exportDirectory.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (ArchiveType !== undefined && ArchiveType !== null) {
            queryParameters = queryParameters.set('ArchiveType', <any>ArchiveType);
        }
        if (IncludeIds !== undefined && IncludeIds !== null) {
            queryParameters = queryParameters.set('IncludeIds', <any>IncludeIds);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get(`${this.configuration.basePath}/api/directories/${encodeURIComponent(String(id))}/actions/export`,
            {
                params: queryParameters,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve all directories.
     * @param IncludeRelated Whether or not to return related objects (Files, Workspaces)
     * @param IncludeFileContent Whether or not to include contents of returned Files. Ignored if IncludeRelated is false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllDirectories(IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Directory>>;
    public getAllDirectories(IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Directory>>>;
    public getAllDirectories(IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Directory>>>;
    public getAllDirectories(IncludeRelated?: boolean, IncludeFileContent?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (IncludeRelated !== undefined && IncludeRelated !== null) {
            queryParameters = queryParameters.set('IncludeRelated', <any>IncludeRelated);
        }
        if (IncludeFileContent !== undefined && IncludeFileContent !== null) {
            queryParameters = queryParameters.set('IncludeFileContent', <any>IncludeFileContent);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Directory>>(`${this.configuration.basePath}/api/directories`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve all directories within a single project.
     * @param projectId 
     * @param IncludeDescendants Whether or not to return only top-level Directories
     * @param IncludeRelated Whether or not to return related objects (Files, Workspaces)
     * @param IncludeFileContent Whether or not to include contents of returned Files. Ignored if IncludeRelated is false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDirectoriesByProject(projectId: string, IncludeDescendants?: boolean, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Directory>>;
    public getDirectoriesByProject(projectId: string, IncludeDescendants?: boolean, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Directory>>>;
    public getDirectoriesByProject(projectId: string, IncludeDescendants?: boolean, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Directory>>>;
    public getDirectoriesByProject(projectId: string, IncludeDescendants?: boolean, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDirectoriesByProject.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (IncludeDescendants !== undefined && IncludeDescendants !== null) {
            queryParameters = queryParameters.set('IncludeDescendants', <any>IncludeDescendants);
        }
        if (IncludeRelated !== undefined && IncludeRelated !== null) {
            queryParameters = queryParameters.set('IncludeRelated', <any>IncludeRelated);
        }
        if (IncludeFileContent !== undefined && IncludeFileContent !== null) {
            queryParameters = queryParameters.set('IncludeFileContent', <any>IncludeFileContent);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Directory>>(`${this.configuration.basePath}/api/projects/${encodeURIComponent(String(projectId))}/directories`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve a single directory.
     * @param id ID of a directory.
     * @param IncludeRelated Whether or not to return related objects (Files, Workspaces)
     * @param IncludeFileContent Whether or not to include contents of returned Files. Ignored if IncludeRelated is false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDirectory(id: string, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Directory>;
    public getDirectory(id: string, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Directory>>;
    public getDirectory(id: string, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Directory>>;
    public getDirectory(id: string, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDirectory.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (IncludeRelated !== undefined && IncludeRelated !== null) {
            queryParameters = queryParameters.set('IncludeRelated', <any>IncludeRelated);
        }
        if (IncludeFileContent !== undefined && IncludeFileContent !== null) {
            queryParameters = queryParameters.set('IncludeFileContent', <any>IncludeFileContent);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Directory>(`${this.configuration.basePath}/api/directories/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve all directories that are children of a specified directory
     * @param directoryId 
     * @param IncludeDescendants Whether or not to return only top-level Directories
     * @param IncludeRelated Whether or not to return related objects (Files, Workspaces)
     * @param IncludeFileContent Whether or not to include contents of returned Files. Ignored if IncludeRelated is false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDirectoryChildren(directoryId: string, IncludeDescendants?: boolean, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Directory>>;
    public getDirectoryChildren(directoryId: string, IncludeDescendants?: boolean, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Directory>>>;
    public getDirectoryChildren(directoryId: string, IncludeDescendants?: boolean, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Directory>>>;
    public getDirectoryChildren(directoryId: string, IncludeDescendants?: boolean, IncludeRelated?: boolean, IncludeFileContent?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (directoryId === null || directoryId === undefined) {
            throw new Error('Required parameter directoryId was null or undefined when calling getDirectoryChildren.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (IncludeDescendants !== undefined && IncludeDescendants !== null) {
            queryParameters = queryParameters.set('IncludeDescendants', <any>IncludeDescendants);
        }
        if (IncludeRelated !== undefined && IncludeRelated !== null) {
            queryParameters = queryParameters.set('IncludeRelated', <any>IncludeRelated);
        }
        if (IncludeFileContent !== undefined && IncludeFileContent !== null) {
            queryParameters = queryParameters.set('IncludeFileContent', <any>IncludeFileContent);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Directory>>(`${this.configuration.basePath}/api/directories/${encodeURIComponent(String(directoryId))}/children`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Import a directory.
     * @param id ID of a directory.
     * @param PreserveIds 
     * @param Archive 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public importDirectory(id: string, PreserveIds?: boolean, Archive?: Blob, observe?: 'body', reportProgress?: boolean): Observable<ImportDirectoryResult>;
    public importDirectory(id: string, PreserveIds?: boolean, Archive?: Blob, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ImportDirectoryResult>>;
    public importDirectory(id: string, PreserveIds?: boolean, Archive?: Blob, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ImportDirectoryResult>>;
    public importDirectory(id: string, PreserveIds?: boolean, Archive?: Blob, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling importDirectory.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (PreserveIds !== undefined && PreserveIds !== null) {
            queryParameters = queryParameters.set('PreserveIds', <any>PreserveIds);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: this.encoder});
        }

        if (Archive !== undefined) {
            formParams = formParams.append('Archive', <any>Archive) as any || formParams;
        }

        return this.httpClient.post<ImportDirectoryResult>(`${this.configuration.basePath}/api/directories/${encodeURIComponent(String(id))}/actions/import`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Partial update a directory.
     * @param id ID of a directory.
     * @param PartialEditDirectoryCommand 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public partialEditDirectory(id: string, PartialEditDirectoryCommand?: PartialEditDirectoryCommand, observe?: 'body', reportProgress?: boolean): Observable<Directory>;
    public partialEditDirectory(id: string, PartialEditDirectoryCommand?: PartialEditDirectoryCommand, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Directory>>;
    public partialEditDirectory(id: string, PartialEditDirectoryCommand?: PartialEditDirectoryCommand, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Directory>>;
    public partialEditDirectory(id: string, PartialEditDirectoryCommand?: PartialEditDirectoryCommand, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling partialEditDirectory.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<Directory>(`${this.configuration.basePath}/api/directories/${encodeURIComponent(String(id))}`,
            PartialEditDirectoryCommand,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
