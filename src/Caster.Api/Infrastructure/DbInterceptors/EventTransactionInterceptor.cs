// Copyright 2021 Carnegie Mellon University. All Rights Reserved.
// Released under a MIT (SEI)-style license. See LICENSE.md in the project root for license information.

using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Caster.Api.Data;
using Caster.Api.Domain.Events;
using MediatR;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using SimpleInjector;
using SimpleInjector.Lifestyles;

namespace Caster.Api.Infrastructure.DbInterceptors;
public class EventTransactionInterceptor : DbTransactionInterceptor
{
    private readonly Container _container;
    private readonly ILogger<EventTransactionInterceptor> _logger;

    public EventTransactionInterceptor(
        Container container,
        ILogger<EventTransactionInterceptor> logger)
    {
        _container = container;
        _logger = logger;
    }

    public override async Task TransactionCommittedAsync(
        DbTransaction transaction,
        TransactionEndEventData eventData,
        CancellationToken cancellationToken = default)
    {
        try
        {
            await PublishEvents(eventData);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in EventTransactionInterceptor");
        }
        finally
        {
            await base.TransactionCommittedAsync(transaction, eventData, cancellationToken);
        }
    }

    public override async void TransactionCommitted(
        DbTransaction transaction,
        TransactionEndEventData eventData)
    {
        try
        {
            await PublishEvents(eventData);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in EventTransactionInterceptor");
        }
        finally
        {
            base.TransactionCommitted(transaction, eventData);
        }
    }

    private async Task PublishEvents(TransactionEndEventData eventData)
    {
        var entries = GetEntries(eventData.Context as CasterContext);

        using (var scope = AsyncScopedLifestyle.BeginScope(_container))
        {
            var events = new List<INotification>();
            var mediator = scope.GetRequiredService<IMediator>();

            foreach (var entry in entries)
            {
                var entityType = entry.Entity.GetType();
                Type eventType = null;

                string[] modifiedProperties = null;

                switch (entry.State)
                {
                    case EntityState.Added:
                        eventType = typeof(EntityCreated<>).MakeGenericType(entityType);

                        // Make sure properties generated by the db are set
                        var generatedProps = entry.Properties
                            .Where(x => x.Metadata.ValueGenerated == Microsoft.EntityFrameworkCore.Metadata.ValueGenerated.OnAdd)
                            .ToList();

                        foreach (var prop in generatedProps)
                        {
                            entityType.GetProperty(prop.Metadata.Name).SetValue(entry.Entity, prop.CurrentValue);
                        }

                        break;
                    case EntityState.Modified:
                        eventType = typeof(EntityUpdated<>).MakeGenericType(entityType);
                        modifiedProperties = entry.Properties
                            .Where(x => x.IsModified)
                            .Select(x => x.Metadata.Name)
                            .ToArray();
                        break;
                    case EntityState.Deleted:
                        eventType = typeof(EntityDeleted<>).MakeGenericType(entityType);
                        break;
                }

                if (eventType != null)
                {
                    INotification evt;

                    if (modifiedProperties != null)
                    {
                        evt = Activator.CreateInstance(eventType, new[] { entry.Entity, modifiedProperties }) as INotification;
                    }
                    else
                    {
                        evt = Activator.CreateInstance(eventType, new[] { entry.Entity }) as INotification;
                    }


                    if (evt != null)
                    {
                        events.Add(evt);
                    }
                }
            }

            foreach (var evt in events)
            {
                await mediator.Publish(evt);
            }
        }
    }

    private Entry[] GetEntries(CasterContext db)
    {
        var entries = db.Entries
            .Where(x => x.State == EntityState.Added ||
                        x.State == EntityState.Modified ||
                        x.State == EntityState.Deleted)
            .ToList();

        db.Entries.Clear();
        return entries.ToArray();
    }
}